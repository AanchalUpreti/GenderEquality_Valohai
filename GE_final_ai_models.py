# -*- coding: utf-8 -*-
"""AI_models.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Uz-CAo71_eqktLGNkEHHMdHOeCy76gft

# Imports and downloads
"""

!pip install NRCLex
!pip install torch
!pip install stanza

import stanza
stanza.download('en')
import nltk
nltk.download('punkt')
from bs4 import BeautifulSoup
from nrclex import NRCLex
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.metrics import accuracy_score

"""# Converting Data to JSON"""

def get_character_dictionary_from_html(filename, name_position, dialogue_position, scenario_position):
  """
  This function takes the name of the file, the starting position of the name, dialogue,
  and scenario. Then, returns the dictionary.

    Parameters:
      filename: string: The path of the file to read
      name_position: float: The starting value of left pixel for name of character
      dialogue_position: float: The starting value of left pixel for dialogues
      scenario_position: float: The starting value of left pixel for scenarios

    Returns:
      character_dialogues: dict: A dictionary with every character's dialogues,
                               : The sample format is "Name": list of dialogues
      scenarios: dict: A list of scenarios, with the key "scenarios". It is kept
                      as a dict because we can further classify it into different
                      kinds of scenarios if we want
  """
  with open(filename) as fp:
      soup = BeautifulSoup(fp, "html.parser")

  everything = soup.find_all('div')
  character_dialogues = {}
  scenarios = {'scenarios': []} 
  dialogue = "" 
  dialogue_ready = False
  for div in everything:
    try:
      if float(div['style'].split(';')[1].split(':')[1].split('px')[0]) >= name_position-5 \
       and float(div['style'].split(';')[1].split(':')[1].split('px')[0]) <= name_position+5:
        if dialogue_ready:  # For the first dialogue
          if not character_dialogues.get(character):
            character_dialogues[character] = []
          character_dialogues[character].append(dialogue)
          dialogue = ""
        character = div.text  # Character updated
      if float(div['style'].split(';')[1].split(':')[1].split('px')[0]) >= dialogue_position-5 \
       and float(div['style'].split(';')[1].split(':')[1].split('px')[0]) <= dialogue_position+5:
        dialogue = dialogue + " " + div.text
        dialogue_ready = True
      if float(div['style'].split(';')[1].split(':')[1].split('px')[0]) >= scenario_position-5 \
       and float(div['style'].split(';')[1].split(':')[1].split('px')[0]) <= scenario_position+5:
        scenarios['scenarios'].append(div.text)
    except:
      pass
    
  if not character_dialogues.get(character):
    character_dialogues[character] = []
  character_dialogues[character].append(dialogue)
  dialogue = ""

  return character_dialogues, scenarios

def get_character_dictionary_from_text(filename, name_position, dialogue_position, scenario_position):
  """
  This function converts a text file inot a character dictionary.

    Parameters:
      filename: string: The path of the file to read
      name_position: int: Number of spaces before the name
      dialogue_position: int: Number of spaces before the dialogues
      scenario_position: int: Number of spaces before the scenarios

    Returns:
      character_dialogues: dict: A dictionary with every character's dialogues,
                               : The sample format is "Name": list of dialogues
      scenarios: dict: A list of scenarios, with the key "scenarios". It is kept
                      as a dict because we can further classify it into different
                      kinds of scenarios if we want
  """
  # Filtering the empty lines
  lines = list(filter(lambda x: x!='', open(filename).read().split('\n')))
  character_dialogues = {}
  scenarios = {'scenarios': []} 
  dialogue = "" 
  dialogue_ready = False
  for line in lines:  # for every line
    line_arr = line.split(":") 
    if len(line_arr) == 1:
      scenarios['scenarios'].append(line_arr[0])
    elif len(line_arr) == 2:
      character = line_arr[0]
      dialogue = line_arr[1]
      # If some random line is classified as a dialogue, skip it; 
      if len(character) >= 30:
        continue
      if not character_dialogues.get(character):
          character_dialogues[character] = []
      character_dialogues[character].append(dialogue)
  return character_dialogues, scenarios

"""
Should we write like a driver function?
"""
character_dialogues, scenarios = get_character_dictionary_from_html("hp5.html", 230, 162, 90)
import json
with open('hp.json', 'w') as fp:
    json.dump(character_dialogues, fp)

with open('hp_scenarios.json', 'w') as fp:
    json.dump(scenarios, fp)

"""# Sentiment Analysis"""

def get_sentiments(dialogues):
  """
  Takes a list of dialogues spoken by a character and classify it into
  positive, negative, or neutral sentiment

    Parameters:
      dialogues: list: List of dialogues to be setimentized

    Returns:
      sentiment_count: Count of each sentiment in the dialogues.
  """
  emotions = ['Negative', 'Neutral', 'Positive']
  nlp = stanza.Pipeline(lang='en', processors='tokenize,sentiment')
  doc = nlp(". ".join(dialogues))
  sentiment = [i.sentiment for i in doc.sentences]
  sentiment_count = np.unique(sentiment, return_counts=True)
  
  # Getting the right name for the emotion instead of numeric number
  sentiment_count = dict(zip(map(lambda x: emotions[x], sentiment_count[0]),
                             sentiment_count[1]))
  return sentiment_count

"""
Main script that reads the databases, run stanza on them, and save the final dataframe
"""
movies = ['marvel', 'hp', 'PP', 'horror']  # A list of movies data bases we are going to work with
data_frames = {}
character_sentiments = {}
genders = {}  # A dict of dict

# Reading the files for all the movies
for movie in movies:
  data_frames[movie] = pd.read_csv(movie+'_db.csv').drop('Unnamed: 0', axis=1)

# Running Stanza on the characters
for movie in movies:
  df = data_frames[movie]  # for convinience
  for character in df.character.unique():
    if not character_sentiments.get(movie):
      character_sentiments[movie] = {}
      genders[movie] = dict(data_frames[movie].groupby('character')['types'].agg('unique').apply(lambda x: x[0]).fillna('NA'))
    character_sentiments[movie][character] = get_sentiments(df[df.character==character]['text'])

def plot_emotions_movies(character_sentiments, movies):
  """
  This functions plots the emotions of male and female characters for the list of
  movies given

    Parameters:
      character_sentiments: dict: having the name of the character and sentiments
      movies: list: The list of movies whose characters we have to plot

    Returns:
      Nothing
  """
  fig, axs = plt.subplots(len(movies), 2)
  i = 0
  for movie in movies:
    ch = character_sentiments[movie]
    
    df1 = pd.DataFrame(ch).transpose().fillna(0)
    df1['gender'] = df1.index
    df1['gender'] = df1.gender.apply(lambda x: genders[movie].get(x, '' ))

    df2 = df1[df1.gender == 'male']
    df2.drop('gender', axis=1, inplace=True)

    df3 = df1[df1.gender == 'female']
    df3.drop('gender', axis=1, inplace=True)

    df2.div(df2.sum(axis=1), axis=0).reset_index().fillna(0).mean().plot.pie(y=df.index,
              shadow=False,
              ax=axs[i, 0], 
              wedgeprops={'width':0.5},
              startangle=90,
              title='Average Sentiment of Male characters - ' + movie,
              autopct='%1.1f%%',
              figsize=(15, 25))

    df3.div(df3.sum(axis=1), axis=0).reset_index().fillna(0).mean().plot.pie(y=df.index,
              shadow=False,
              ax=axs[i, 1],
              wedgeprops={'width':0.5},
              startangle=90,
              title='Average Sentiment of Female characters - ' + movie,
              autopct='%1.1f%%')  
    i+=1
  plt.savefig('a.jpg')

plot_emotions_movies(character_sentiments, movies)

def plot_character(character_name, movie_name, character_sentiments):
  """
  This functions takes the name of the character, and plot their sentiment in a ring chart
  
    Parameters:
      character_name: str: The name of the character who emotions are to be displayed\
      movie_name: str: the movie which the character belongs to
      character_sentiments: dict: having the name of the character and sentiments
    Returns:
      Nothing
  """
  if not character_sentiments.get(movie_name, {}).get(character_name):
    print("The character does not exist")
    return
  plt.figure(figsize=(10,10))
  plt.pie(character_sentiments[movie_name][character_name].values(), 
          labels=character_sentiments[movie_name][character_name].keys(),
          # ax=axs[i, 1],
          wedgeprops={'width':0.5},
          startangle=90,
          autopct='%1.1f%%')
  plt.title(character_name)

plot_character('THOR', 'marvel', character_sentiments)
plot_character('LOKI', 'marvel', character_sentiments)

"""
We are running stanza on Harry's dialogues.
Then we will save the file
"""

harry = pd.read_csv('harry.csv')
emotions = ['Negative', 'Neutral', 'Positive']
nlp = stanza.Pipeline(lang='en', processors='tokenize,sentiment')
doc = nlp(". ".join(harry.text))
sentiment = [i.sentiment for i in doc.sentences]
text = [i.text for i in doc.sentences]

text = [i.text for i in doc.sentences]
harry_stanza = pd.DataFrame({'text':text,'sentiment':sentiment})
harry_stanza.to_csv('harry_stanza.csv', index=False)

"""
Here we are reading the file again after manually annotating it as well
"""
harry_annotated = pd.read_csv('harry_stanza_annotated.csv')
print(accuracy_score(harry_annotated['person 1'], harry_annotated['person 2']))
print(accuracy_score(harry_annotated['sentiment'], harry_annotated['person 1']))
print(accuracy_score(harry_annotated['sentiment'], harry_annotated['person 2']))

"""# Emotions Analysis"""

def func(x):
  """
  A functıon to apply NRCLEX on a dıalogue. It also computes new emotıons ıncludıng,
  anxıety, prıde, envy, domınance, and curıosıty. Thıs ıs a functıon that ıs only
  used to apply on a serıes on dıalogue

    Parameters:
      x: str: A strıng, preferably dıalogue, on whıch we have to run NRCLEX
    
    Returns:
      res: dıct: wıth emotıons, havıng 1 ıf the emotıon ıs present, 0 otherwıse
  """
  xx = 'NA'
  res = NRCLex(x).affect_frequencies
  del res['negative']
  del res['positive']
  total = sum(res.values())
  if total != 0:
    for keys in res.keys():
      res[keys] = res[keys]/total
  if res.get('anticipation') and res.get('fear'):
    res['anxiety'] = res['fear']*res['anticipation']
  if res.get('anger'):
    if res.get('joy'):
      res['pride'] = res['anger']*res['joy']
    if res.get('sadness'):
      res['envy'] = res['anger']*res['sadness']
    if res.get('trust'):
      res['dominance'] = res['anger']*res['trust']
  if res.get('surprise') and res.get('trust'):
    res['curiosity'] = res['surprise']*res['trust']
  
  for key in res.keys():
    if res[key] > 0:
      res[key] = 1 
  return res

for movie in movies:
  df = data_frames[movie]
  df['emotions'] = df['text'].apply(func)

"""
Code to plot some of the emotıons for our report and the presentatıon
"""
basic_emotions = ['fear', 'anger', 'trust', 'surprise', 'sadness', 'disgust', 'joy', 'anticipation']
derived_emotions = ['anxiety', 'pride', 'envy', 'dominance', 'curiosity']
fig, axs = plt.subplots(len(movies), 4, sharey=True)

i = 0
for movie in movies:
  df = data_frames[movie]
  df2 = pd.concat([df.drop(['emotions'], axis = 1), df['emotions'].apply(pd.Series)], axis = 1).fillna(0)

  df2[(df2.types=='male')][basic_emotions].sum(axis=0).plot(
      labels=basic_emotions, 
      label="",
      ax=axs[i, 0],
      kind='pie', 
      autopct='%1.1f%%',
      figsize=(20,20)
      )
  axs[i,0].set_title("%s | Basic Male \n" % movie, fontsize=12)
  
  df2[(df2.types=='male')][derived_emotions].sum(axis=0).plot(
      labels=derived_emotions, 
      label="",
      ax=axs[i, 1],
      kind='pie', 
      autopct='%1.1f%%',
      figsize=(20,20)
      )
  axs[i,1].set_title("%s | Conjugate Male \n" % movie, fontsize=12)
  
  df2[(df2.types=='female')][basic_emotions].sum(axis=0).plot(
      labels=basic_emotions, 
      label="",
      ax=axs[i, 2],
      kind='pie', 
      autopct='%1.1f%%',
      figsize=(20,20)
      )
  axs[i,2].set_title("%s | Basic Female \n" % movie, fontsize=12)
  
  df2[(df2.types=='female')][derived_emotions].sum(axis=0).plot(
      labels=derived_emotions, 
      label="",
      ax=axs[i, 3],
      kind='pie', 
      autopct='%1.1f%%',
      figsize=(20,20)
      )
  axs[i,3].set_title("%s | Conjugate Female \n" % movie, fontsize=12)
  
  i += 1
  plt.savefig('b.jpg')

# ['marvel', 'hp', 'PP', 'horror']

"""
Code to plot emotıons of 1 character. Maınly for presentatıon and the report
"""
movie = 'hp'
character = 'DUDLEY'

df = data_frames[movie]
df2 = pd.concat([df.drop(['emotions'], axis = 1), df['emotions'].apply(pd.Series)], axis = 1).fillna(0)

df2[(df2.character==character)][derived_emotions].sum(axis=0).plot(
    labels=derived_emotions, 
    label=character,
    kind='pie', 
    wedgeprops={'width':0.5},
    autopct='%1.1f%%',
    figsize=(10,10)
    )